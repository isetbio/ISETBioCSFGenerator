function t_AOtumblingEscene()

    % Initialize
    clear; close all;
    
    % Make sure figures and results directories exist so that output writes
    % don't fail
    rootPath = ISETBioCSFGeneratorRootPath;
    if (~exist(fullfile(rootPath,'local','figures'),'dir'))
        mkdir(fullfile(rootPath,'local','figures'));
    end

    % Load in a monitor that mimics the primaries in the Berkely AO system.
    theDisplay = load(fullfile(rootPath,'data','monoDisplay.mat'));
    presentationDisplay = theDisplay.monoDisplay;
    
    % Set the parameters for the AO mimicing display
    sceneParams = sceTumblingEscene;
    sceneParams.presentationDisplay = presentationDisplay;
    sceneParams.plotDisplayCharacteristics = false;

    % Define the foreground (E) and background RGB wrt the monochromatic
    % monitor.  I think the Berkeley experiments use only the green
    % channel, so we'll do that here.
    sceneParams.chromaSpecification.backgroundRGB = [0 0 0];
    sceneParams.chromaSpecification.foregroundRGB = [0 0.5 0];

    % Instantiate a tumblingEsceneEngine for 0 deg rotation E
    sceneParams.letterRotationDegs = 0;
    tumblingEsceneEngine0degs = sceneEngine(@sceTumblingEscene,sceneParams);

    % Generate sceneEngine for 90 deg rotation E
    sceneParams.letterRotationDegs = 90;
    tumblingEsceneEngine90degs = sceneEngine(@sceTumblingEscene,sceneParams);

    % Generate sceneEngine for 180 deg rotation E
    sceneParams.letterRotationDegs = 180;
    tumblingEsceneEngine180degs = sceneEngine(@sceTumblingEscene,sceneParams);

    % Generate sceneEngine for 270 deg rotation E
    sceneParams.letterRotationDegs = 270;
    tumblingEsceneEngine270degs = sceneEngine(@sceTumblingEscene,sceneParams);

    % Generate params for the background scene
    backgroundSceneParams = sceneParams;
    backgroundSceneParams.chromaSpecification.foregroundRGB = sceneParams.chromaSpecification.backgroundRGB;
    backgroundSceneEngine = sceneEngine(@sceTumblingEscene,backgroundSceneParams);

    % Generate scenes with size of 0.1 deg
    sizeDegs = 0.1;
    theSmallEsceneSequence0degs = tumblingEsceneEngine0degs.compute(sizeDegs);
    theSmallEsceneSequence90degs = tumblingEsceneEngine90degs.compute(sizeDegs);
    theSmallEsceneSequence180degs = tumblingEsceneEngine180degs.compute(sizeDegs);
    theSmallEsceneSequence270degs = tumblingEsceneEngine270degs.compute(sizeDegs);
    theSmallBackgroundSceneSequence = backgroundSceneEngine.compute(sizeDegs);

    % Get first frame of the scene sequences
    theSmallEscene0degs = theSmallEsceneSequence0degs{1};
    theSmallEscene90degs = theSmallEsceneSequence90degs{1};
    theSmallEscene180degs = theSmallEsceneSequence180degs{1};
    theSmallEscene270degs = theSmallEsceneSequence270degs{1};
    theSmallBackgroundScene = theSmallBackgroundSceneSequence{1};

    subplotPosVectors = NicePlot.getSubPlotPosVectors(...
       'rowsNum', 1, ...
       'colsNum', 4, ...
       'heightMargin',  0.0, ...
       'widthMargin',    0.05, ...
       'leftMargin',     0.05, ...
       'rightMargin',    0.00, ...
       'bottomMargin',   0.05, ...
       'topMargin',      0.00);

    domainVisualizationLimits = 0.3*0.5*[-1 1 -1 1];

    hFig = figure(1);
    clf;
    set(hFig, 'Position', [10 10 1550 400], 'Color', [1 1 1]);
    ax = subplot('Position', subplotPosVectors(1,1).v);
    visualizeScene(theSmallEscene0degs, ...
            'spatialSupportInDegs', true, ...
            'crossHairsAtOrigin', true, ...
            'displayRadianceMaps', false, ...
            'avoidAutomaticRGBscaling', true, ...
            'noTitle', true, ...
            'axesHandle', ax);
    set(ax, 'XLim', [domainVisualizationLimits(1) domainVisualizationLimits(2)], ...
            'YLim', [domainVisualizationLimits(3) domainVisualizationLimits(4)], ...
            'XTick', [-0.1 0 0.1], 'YTick', [-0.1 0 0.1] ...
            );

    ax = subplot('Position', subplotPosVectors(1,2).v);
    visualizeScene(theSmallEscene90degs, ...
            'spatialSupportInDegs', true, ...
            'crossHairsAtOrigin', true, ...
            'displayRadianceMaps', false, ...
            'avoidAutomaticRGBscaling', true, ...
            'noYLabel', true, ...
            'noYTicks', true, ...
            'noTitle', true, ...
            'axesHandle', ax);
    set(ax, 'XLim', [domainVisualizationLimits(1) domainVisualizationLimits(2)], ...
            'YLim', [domainVisualizationLimits(3) domainVisualizationLimits(4)], ...
            'XTick', [-0.1 0 0.1], 'YTick', [-0.1 0 0.1] ...
            );

    ax = subplot('Position', subplotPosVectors(1,3).v);
    visualizeScene(theSmallEscene180degs, ...
            'spatialSupportInDegs', true, ...
            'crossHairsAtOrigin', true, ...
            'displayRadianceMaps', false, ...
            'avoidAutomaticRGBscaling', true, ...
            'noYLabel', true, ...
            'noYTicks', true, ...
            'noTitle', true, ...
            'axesHandle', ax);
    set(ax, 'XLim', [domainVisualizationLimits(1) domainVisualizationLimits(2)], ...
            'YLim', [domainVisualizationLimits(3) domainVisualizationLimits(4)], ...
            'XTick', [-0.1 0 0.1], 'YTick', [-0.1 0 0.1] ...
            );

    ax = subplot('Position', subplotPosVectors(1,4).v);
    visualizeScene(theSmallEscene270degs, ...
            'spatialSupportInDegs', true, ...
            'crossHairsAtOrigin', true, ...
            'displayRadianceMaps', false, ...
            'avoidAutomaticRGBscaling', true, ...
            'noYLabel', true, ...
            'noYTicks', true, ...
            'noTitle', true, ...
            'axesHandle', ax);
    set(ax, 'XLim', [domainVisualizationLimits(1) domainVisualizationLimits(2)], ...
            'YLim', [domainVisualizationLimits(3) domainVisualizationLimits(4)], ...
            'XTick', [-0.1 0 0.1], 'YTick', [-0.1 0 0.1] ...
            );

    projectBaseDir = ISETBioCSFGeneratorRootPath;
    pdfFile = fullfile(projectBaseDir,'figures','t_AOTumblingScene_stimuli.pdf');
    NicePlot.exportFigToPDF(pdfFile,hFig, 300);
end

